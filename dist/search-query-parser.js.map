{"version":3,"sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/webpack/bootstrap","webpack://[name]/./lib/search-query-parser.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","string","options","tokenize","alwaysArray","offsets","indexOf","keywords","ranges","parseResult","text","exclusion","terms","regex","match","exec","sepIndex","split","slice","val","replace","n1","push","keyword","offsetStart","index","offsetEnd","length","isExcludedTerm","Array","reverse","term","pop","isKeyword","isExclusion","test","_key","isRange","values","concat","rangeValues","from","to","join","trim","exclude"],"mappings":"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","file":"search-query-parser.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"search-query-parser\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"search-query-parser\"] = factory();\n\telse\n\t\troot[\"search-query-parser\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/*!\n * search-query-parser.js\n * Copyright(c) 2014-2019\n * MIT Licensed\n */\n\nexport type SearchParserOptions = {\n    offsets?: boolean;\n    tokenize?: boolean;\n    keywords?: string[];\n    ranges?: string[];\n    alwaysArray?: boolean;\n}\n\nexport type SearchParserOffset = (SearchParserKeyWordOffset | SearchParserTextOffset) & {\n    offsetStart: number;\n    offsetEnd: number;\n}\n  \nexport type SearchParserKeyWordOffset = {\n    keyword: string;\n    value: string;  \n}\n  \nexport type SearchParserTextOffset = {\n    text: string;\n}\n\nexport type SearchParserDictionary = {\n    [key: string]: any;\n}  \n\nexport type SearchParserResult = SearchParserDictionary & {\n    text: string | string[];\n    offsets?: SearchParserOffset[];\n    exclude?: SearchParserDictionary;\n}\n\nexport function parse(string = '', options: SearchParserOptions): SearchParserResult | string {\n\n    // Merge options with default options\n    options = {\n        tokenize: false,\n        alwaysArray: false,\n        offsets: true,\n        ...options\n    };\n\n    // When only a simple string is passed, return it\n    if (string.indexOf(':') === -1 && options.tokenize == null) {\n        return string;\n\n    // When no keywords or ranges set, treat as a simple string\n    } else if (options.keywords == null && options.ranges == null && options.tokenize == false){\n        return string;\n    \n    // Otherwise parse the advanced query syntax\n    } else {\n\n        // Init object to store the query object\n        let parseResult: SearchParserResult = { text: [] };\n\n        // When offsets is true, create their array\n        if (options.offsets) {\n            parseResult.offsets = [];\n        }\n\n        let exclusion: SearchParserDictionary = {};\n        let terms: SearchParserOffset[] = [];\n\n        // Get a list of search terms respecting single and double quotes\n        let regex = /(\\S+:'(?:[^'\\\\]|\\\\.)*')|(\\S+:\"(?:[^\"\\\\]|\\\\.)*\")|(-?\"(?:[^\"\\\\]|\\\\.)*\")|(-?'(?:[^'\\\\]|\\\\.)*')|\\S+|\\S+:\\S+/g;\n        let match;\n        while ((match = regex.exec(string)) !== null) {\n            let term = match[0];\n            let sepIndex = term.indexOf(':');\n            if (sepIndex !== -1) {\n                let split = term.split(':'),\n                        key = term.slice(0, sepIndex),\n                        val = term.slice(sepIndex + 1);\n                // Strip surrounding quotes\n                val = val.replace(/^\\\"|\\\"$|^\\'|\\'$/g, '');\n                // Strip backslashes respecting escapes\n                val = (val + '').replace(/\\\\(.?)/g, function (s, n1) {\n                    switch (n1) {\n                    case '\\\\':\n                        return '\\\\';\n                    case '0':\n                        return '\\u0000';\n                    case '':\n                        return '';\n                    default:\n                        return n1;\n                    }\n                });\n                terms.push({\n                    keyword: key,\n                    value: val,\n                    offsetStart: match.index,\n                    offsetEnd: match.index + term.length\n                });\n            } else {\n                let isExcludedTerm = false;\n                if (term[0] === '-') {\n                    isExcludedTerm = true;\n                    term = term.slice(1);\n                }\n\n                // Strip surrounding quotes\n                term = term.replace(/^\\\"|\\\"$|^\\'|\\'$/g, '');\n                // Strip backslashes respecting escapes\n                term = (term + '').replace(/\\\\(.?)/g, function (s, n1) {\n                    switch (n1) {\n                    case '\\\\':\n                        return '\\\\';\n                    case '0':\n                        return '\\u0000';\n                    case '':\n                        return '';\n                    default:\n                        return n1;\n                    }\n                });\n\n                if (isExcludedTerm) {\n                    if (exclusion['text']) {\n                        if (exclusion['text'] instanceof Array) {\n                            exclusion['text'].push(term);\n                        } else {\n                            exclusion['text'] = [exclusion['text']];\n                            exclusion['text'].push(term);\n                        }\n                    } else {\n                        // First time seeing an excluded text term\n                        exclusion['text'] = term;\n                    }\n                } else {\n                    terms.push({\n                        text: term,\n                        offsetStart: match.index,\n                        offsetEnd: match.index + term.length\n                    });\n                }\n            }\n        }\n\n        // Reverse to ensure proper order when pop()'ing.\n        terms.reverse();\n\n        // For each search term\n        let term: SearchParserOffset;\n        while (term = terms.pop()) {\n\n            // When just a simple term\n            if ('text' in term) {\n\n                // We add it as pure text\n                (parseResult.text as string[]).push(term.text);\n\n                // When offsets is true, push a new offset\n                if (options.offsets) {\n                    parseResult.offsets.push(term);\n                }\n\n            // We got an advanced search syntax\n            } else {\n                let key = term.keyword;\n                // Check if the key is a registered keyword\n                options.keywords = options.keywords || [];\n                let isKeyword = false;\n                let isExclusion = false;\n                if (!/^-/.test(key)) {\n                        isKeyword = !(-1 === options.keywords.indexOf(key));\n                } else    if (key[0] === '-') {\n                        let _key = key.slice(1);\n                        isKeyword = !(-1 === options.keywords.indexOf(_key))\n                        if (isKeyword) {\n                                key = _key;\n                                isExclusion = true;\n                        }\n                }\n\n                // Check if the key is a registered range\n                options.ranges = options.ranges || [];\n                let isRange = !(-1 === options.ranges.indexOf(key));\n                // When the key matches a keyword\n                if (isKeyword) {\n                    // When offsets is true, push a new offset\n                    if (options.offsets) {\n                        parseResult.offsets.push({\n                            keyword: key,\n                            value: term.value,\n                            offsetStart: isExclusion ? term.offsetStart + 1 : term.offsetStart,\n                            offsetEnd: term.offsetEnd\n                        });\n                    }\n\n                    let value = term.value;\n                    // When value is a thing\n                    if (value.length) {\n                        // Get an array of values when several are there\n                        let values = value.split(',');\n                        if (isExclusion) {\n                            if (exclusion[key]) {\n                                // ...many times...\n                                if (exclusion[key] instanceof Array) {\n                                    // ...and got several values this time...\n                                    if (values.length > 1) {\n                                        // ... concatenate both arrays.\n                                        exclusion[key] = exclusion[key].concat(values);\n                                    }\n                                    else {\n                                        // ... append the current single value.\n                                        exclusion[key].push(value);\n                                    }\n                                }\n                                // We saw that keyword only once before\n                                else {\n                                    // Put both the current value and the new\n                                    // value in an array\n                                    exclusion[key] = [exclusion[key]];\n                                    exclusion[key].push(value);\n                                }\n                            }\n                            // First time we see that keyword\n                            else {\n                                // ...and got several values this time...\n                                if (values.length > 1) {\n                                    // ...add all values seen.\n                                    exclusion[key] = values;\n                                }\n                                // Got only a single value this time\n                                else {\n                                    // Record its value as a string\n                                    if (options.alwaysArray) {\n                                        // ...but we always return an array if option alwaysArray is true\n                                        exclusion[key] = [value];\n                                    } else {\n                                        // Record its value as a string\n                                        exclusion[key] = value;\n                                    }\n                                }\n                            }\n                        } else {\n                            // If we already have seen that keyword...\n                            if (parseResult[key]) {\n                                // ...many times...\n                                if (parseResult[key] instanceof Array) {\n                                    // ...and got several values this time...\n                                    if (values.length > 1) {\n                                        // ... concatenate both arrays.\n                                        parseResult[key] = parseResult[key].concat(values);\n                                    }\n                                    else {\n                                        // ... append the current single value.\n                                        parseResult[key].push(value);\n                                    }\n                                }\n                                // We saw that keyword only once before\n                                else {\n                                    // Put both the current value and the new\n                                    // value in an array\n                                    parseResult[key] = [parseResult[key]];\n                                    parseResult[key].push(value);\n                                }\n                            }\n                            // First time we see that keyword\n                            else {\n                                // ...and got several values this time...\n                                if (values.length > 1) {\n                                    // ...add all values seen.\n                                    parseResult[key] = values;\n                                }\n                                // Got only a single value this time\n                                else {\n                                    if (options.alwaysArray) {\n                                        // ...but we always return an array if option alwaysArray is true\n                                        parseResult[key] = [value];\n                                    } else {\n                                        // Record its value as a string\n                                        parseResult[key] = value;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                \n                // The key allows a range\n                } else if (isRange) {\n                    \n                    // When offsets is true, push a new offset\n                    if (options.offsets) {\n                        parseResult.offsets.push(term);\n                    }\n\n                    let value = term.value;\n\n                    // Range are separated with a dash\n                    let rangeValues = value.split('-');\n\n                    // When both end of the range are specified\n                    // keyword:XXXX-YYYY\n                    parseResult[key] = {};\n                    if (2 === rangeValues.length) {\n                        parseResult[key].from = rangeValues[0];\n                        parseResult[key].to = rangeValues[1];\n                    \n                    // When pairs of ranges are specified\n                    // keyword:XXXX-YYYY,AAAA-BBBB\n                    } else if (rangeValues.length % 2 === 0) {\n                        //\n\n                    // When only getting a single value,\n                    // or an odd number of values\n                    } else {\n                        parseResult[key].from = value;\n                    }\n\n                } else {\n                    // We add it as pure text\n                    let text = term.keyword + ':' + term.value;\n                    (parseResult.text as string[]).push(text);\n\n                    // When offsets is true, push a new offset\n                    if (options.offsets) {\n                        parseResult.offsets.push({\n                            text: text,\n                            offsetStart: term.offsetStart,\n                            offsetEnd: term.offsetEnd\n                        });\n                    }\n                }\n            }\n        }\n\n        // Concatenate all text terms if any\n        if (parseResult.text.length) {\n            if (options.tokenize === false) {\n                parseResult.text = (parseResult.text as string[]).join(' ').trim();\n            }\n\n        // Just remove the attribute text when it's empty\n        } else {\n            delete parseResult.text;\n        }\n\n        // Return forged query object\n        parseResult.exclude = exclusion;\n        return parseResult;\n    }\n\n};\n"],"sourceRoot":""}